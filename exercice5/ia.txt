QUESTION :

Identifie le problÃ¨me majeur du code suivant et trouve une solution viable pour y remÃ©dier : 

traitement.php
<?php

$user_input = $_GET['user_id']; $query = "SELECT * FROM users WHERE id = $user_input"; $result = mysqli_query($conn, $query); echo "Utilisateur trouvÃ© : " . $user_input;

?>


fetch.js
function fetchData(id) {
    const url = 'traitement.php?user_id=' + id;
    fetch(url)
      .then(response => response.json())
      .then(data => console.log(data));
}

REPONSE :

ğŸš¨ ProblÃ¨me majeur

Le problÃ¨me majeur de ce code est une faille dâ€™injection SQL dans le fichier traitement.php.

$user_input = $_GET['user_id'];
$query = "SELECT * FROM users WHERE id = $user_input";


ğŸ‘‰ La donnÃ©e user_id provient directement de lâ€™utilisateur (URL) et est injectÃ©e sans validation ni protection dans la requÃªte SQL.

Un attaquant peut appeler par exemple :

traitement.php?user_id=1 OR 1=1


Ce qui produira :

SELECT * FROM users WHERE id = 1 OR 1=1


â¡ï¸ RÃ©sultat : exposition de toutes les donnÃ©es de la table users
â¡ï¸ GravitÃ© : critique (sÃ©curitÃ©)

âœ… Solution viable
1ï¸âƒ£ Utiliser des requÃªtes prÃ©parÃ©es (obligatoire)

Les requÃªtes prÃ©parÃ©es empÃªchent toute interprÃ©tation malveillante de lâ€™entrÃ©e utilisateur.

<?php
header('Content-Type: application/json');

$stmt = $conn->prepare("SELECT * FROM users WHERE id = ?");
$stmt->bind_param("i", $_GET['user_id']); // i = integer
$stmt->execute();

$result = $stmt->get_result();
$user = $result->fetch_assoc();

echo json_encode($user);
?>


ğŸ” BÃ©nÃ©fices :

Protection contre lâ€™injection SQL

Typage strict des paramÃ¨tres

Code sÃ©curisÃ© et maintenable

âš ï¸ ProblÃ¨me secondaire (fonctionnel)

Dans fetch.js :

.then(response => response.json())


Mais le PHP renvoyait :

echo "Utilisateur trouvÃ© : " . $user_input;


â¡ï¸ Ce nâ€™est pas du JSON, ce qui provoque une erreur cÃ´tÃ© JavaScript.

âœ… La solution ci-dessus corrige aussi ce point en renvoyant du JSON valide avec le bon header.

ğŸ§  RÃ©sumÃ©
ProblÃ¨me    Impact    Solution
Injection SQL    ğŸ”´ Critique    RequÃªtes prÃ©parÃ©es
DonnÃ©es utilisateur non filtrÃ©es    ğŸ”´ Critique    Binding + typage
RÃ©ponse non JSON    ğŸŸ  Moyenne    json_encode() + header

ğŸ‘‰ Bonne pratique clÃ© :

Ne jamais faire confiance aux donnÃ©es utilisateur et toujours utiliser des requÃªtes prÃ©parÃ©es.

Si tu veux, je peux aussi proposer une version avec PDO, souvent recommandÃ©e en environnement professionnel.